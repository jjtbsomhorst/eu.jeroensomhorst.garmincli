<?php
namespace App\Command;
use App\GarminConnectExtended;
use dawguk\GarminConnect;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Question\ChoiceQuestion;
use Symfony\Component\Console\Question\ConfirmationQuestion;
use Symfony\Component\Console\Question\Question;
class GarminCliCommand extends Command
{
    private string $workingDir = '/var/www/html/garmin';
    private array $exportTypes = [GarminConnectExtended::EXPORT_TYPE_ACTIVITIES,GarminConnectExtended::EXPORT_TYPE_SEGMENTS];
    private array $exportSize = ['all','last 10'];
    private array $typesToExport = [];
    private string $whatToExport = 'all';
    private string $exportFormat = GarminConnect::DATA_TYPE_GPX;

    private GarminConnectExtended $client;
    private string $username = "";
    private string $password = "";


    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub
        $this->setName('garminexportcommand');
        $this->setDescription('Command to export workouts, activities or segments from garmin connect');
    }

    private function hasConfiguration() : bool
    {
        $f = new \SplFileInfo('settings.json');
        return $f->isFile();
    }

    private function readConfiguration(){
        $f=  new \SplFileObject("settings.json","r");
        $c = $f->fgets();
        if($c !== false){
            $json = json_decode($c);
            $this->workingDir = $json->workingdir ?? $this->workingDir;
            $this->typesToExport = $json->typestoexport ?? [];
            $this->whatToExport  = $json->exportsize ?? $this->whatToExport;
            $this->exportFormat = $json->exportformat ?? $this->exportFormat;
            $this->username = $json->username ?? $this->username;
            $this->password = $json->password ?? $this->password;
        }
    }

    private function storeSettings(){
        $f = new \SplFileObject("settings.json","w+");
        $json = array(
            "username" => $this->username,
            "password" => $this->password,
            "workingdir" => $this->workingDir,
            "typestoexport" => $this->typesToExport,
            "exportsize" => $this->whatToExport,
            "exportformat" => $this->exportFormat
        );
        $f->fwrite(json_encode($json));

    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $helper = $this->getHelper('question');
        if($this->hasConfiguration()){
            $this->readConfiguration();
            $output->writeln(sprintf("Found configuration file: "));
            $this->showConfiguration($output);
            $q = new ChoiceQuestion("Use these settings?",['yes','no'],'yes');
            $a = $helper->ask($input,$output,$q);
            if($a == 'yes'){
                return $this->doExport($input,$output);
            }
        }
        $question = new Question(sprintf("Please specify username. (Default %s):",$this->username),$this->username);
        $this->username = $helper->ask($input,$output,$question);

        $question = new Question(sprintf("Please specify password. (Default %s):",$this->password),$this->password);
        $this->password = $helper->ask($input,$output,$question);

        $question = new Question(sprintf('Please specify working directory. Default %s ',$this->workingDir),$this->workingDir);
        $this->workingDir =  $helper->ask($input,$output,$question);

        $question = new ChoiceQuestion('Please specify what to export',$this->exportSize,$this->whatToExport);
        $this->whatToExport = $helper->ask($input,$output,$question);

        $question = new ChoiceQuestion('Please specify what types to export',$this->exportTypes,implode(",",$this->typesToExport));
        $question->setMultiselect(true);
        $this->typesToExport = $helper->ask($input,$output,$question);

        $question = new ChoiceQuestion('Please specify which format to export',[GarminConnect::DATA_TYPE_FIT,GarminConnect::DATA_TYPE_GOOGLE_EARTH,GarminConnect::DATA_TYPE_GPX,GarminConnect::DATA_TYPE_TCX],$this->exportFormat);
        $this->exportFormat = $helper->ask($input,$output,$question);

        $output->writeln(sprintf("Using following settings:"));
        $this->showConfiguration($output);


        $q = new ConfirmationQuestion("Store these settings and continue?",true);
        $a = $helper->ask($input,$output,$q);
        if($q){
            $this->storeSettings();
            return $this->doExport($input,$output);
        }



    }

    protected function doExport(InputInterface $input, OutputInterface $output){
        $output->writeln(sprintf("Exporting: %s",implode(',',$this->typesToExport)));

        $this->client = new GarminConnectExtended(['username'=>$this->username,'password'=>$this->password]);
        $failures = false;
        foreach($this->typesToExport as $type){
            switch($type){
                case GarminConnectExtended::EXPORT_TYPE_SEGMENTS:
                    if($this->exportSegments($output) == COMMAND::FAILURE){
                        $failures = true;
                        $output->writeln("Failure during export of activities");
                    }
                    break;
                case GarminConnectExtended::EXPORT_TYPE_ACTIVITIES:
                    if($this->exportActivities($output) == COMMAND::FAILURE){
                        $failures = true;
                        $output->writeln("Failure during export of activities");
                    }
                    break;
                case GarminConnectExtended::EXPORT_TYPE_WORKOUTS:
                    if($this->exportWorkouts($output) == COMMAND::FAILURE){
                        $failures = true;
                        $output->writeln("Failure during export of activities");
                    }
                    break;
            }

        }

        if($failures){
            return COMMAND::FAILURE;
        }
        RETURN COMMAND::SUCCESS;
    }


    /**
     * @param OutputInterface $output
     * @return int
     * @throws GarminConnect\exceptions\UnexpectedResponseCodeException
     */
    protected function exportActivities(OutputInterface $output): int
    {
        $output->writeln('Start retrieving activities');
        $activities = array();
        if ($this->whatToExport == 'all') {
            $intStart = 0;
            $limit = 500;
            $result = $this->client->getActivityList($intStart, $limit, null, 'startLocal', 'desc');
            while (!empty($result)) {
                $activities = array_merge($activities, $result);
                $intStart += 500;
                $limit += 500;
                $result = $this->client->getActivityList($intStart, $limit, null, 'startLocal', 'desc');
            }

        } else {
            $activities = $this->client->getActivityList(0, 10, null, 'startLocal', 'desc');
        }

        $output->writeln(sprintf("Found %s activities", count($activities)));
        $failures = false;
        foreach ($activities as $activity) {
            $output->writeln(sprintf('Retrieve %s for activity %s', $this->exportFormat, $activity->activityId));
            $gpx = $this->client->getDataFile($this->exportFormat, $activity->activityId);
            $filename = sprintf("%s/%s.%s", $this->workingDir, $activity->activityId, $this->exportFormat);
            $output->writeln("Exporting to {$filename}");
            if (!file_exists($filename)) {
                $filehandle = fopen($filename, "w");
                if ($filehandle === false) {
                    $output->writeln("Could not export to file!");
                    $failures = true;
                } else {
                    fwrite($filehandle, $gpx);
                    fclose($filehandle);
                    $output->writeln(sprintf("Done exporting %s", $activity->activityId));
                }
            } else {
                $output->writeln(sprintf("File %s already exists", $filename));
            }
        }
        if ($failures) {
            return COMMAND::FAILURE;
        }
        return COMMAND::SUCCESS;
    }

    private function exportWorkouts(OutputInterface $output)
    {
        return COMMAND::SUCCESS;
    }

    private function exportSegments(OutputInterface $output)
    {
        $segments = $this->client->getMySegments();
        $filename = sprintf("%s/%s.%s", $this->workingDir, "mysegments", "json");
        $output->writeln("Exporting to {$filename}");
        if (!file_exists($filename)) {
            $filehandle = fopen($filename, "w");
            if ($filehandle === false) {
                $output->writeln("Could not export to file!");
                $failures = true;
            } else {
                fwrite($filehandle, $segments);
                fclose($filehandle);
                $output->writeln(sprintf("Done exporting %s", "segments"));
            }
        } else {
            $output->writeln(sprintf("File %s already exists", $filename));
        }

        return COMMAND::SUCCESS;
    }

    /**
     * @param OutputInterface $output
     */
    private function showConfiguration(OutputInterface $output): void
    {
        $output->writeln(sprintf("Username: %s", $this->username));
        $output->writeln(sprintf("Password: %s", $this->password));
        $output->writeln(sprintf("Working dir: %s", $this->workingDir));
        $output->writeln(sprintf("Types to export %s", implode(",",$this->typesToExport)));
        $output->writeln(sprintf("Size to export %s", $this->whatToExport));
        $output->writeln(sprintf("Format to export %s", $this->exportFormat));
    }


}