<?php
namespace App\Command;
use App\GarminConnectExtended;
use dawguk\GarminConnect;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Question\ChoiceQuestion;
use Symfony\Component\Console\Question\ConfirmationQuestion;
use Symfony\Component\Console\Question\Question;
class GarminCliCommand extends Command
{
    private string $workingDir = '/var/www/html/garmin';
    private array $exportTypes = [GarminConnectExtended::EXPORT_TYPE_ACTIVITIES,GarminConnectExtended::EXPORT_TYPE_SEGMENTS];
    private array $exportSize = ['all','last 10'];
    private array $typesToExport = [];
    private string $whatToExport = 'all';

    private GarminConnectExtended $client;
    private $exportFormat;

    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub
        $this->setName('garminexportcommand');
        $this->setDescription('Command to export workouts, activities or segments from garmin connect');
        $this->addArgument("username",InputArgument::REQUIRED,'Garmin Connect username');
        $this->addArgument("password",InputArgument::REQUIRED,'Garmin Connect password');
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $username = $input->getArgument('username');
        $password = $input->getArgument('password');
        $helper = $this->getHelper('question');
        $question = new Question('Please specify working directory',$this->workingDir);
        $this->workingDir =  $helper->ask($input,$output,$question);
        $question = new ChoiceQuestion('Please specify what to export',$this->exportSize);
        $this->whatToExport = $helper->ask($input,$output,$question);

        $question = new ChoiceQuestion('Please specify what types to export',$this->exportTypes);
        $question->setMultiselect(true);
        $this->typesToExport = $helper->ask($input,$output,$question);

        $question = new ChoiceQuestion('Please specify which format to export',[GarminConnect::DATA_TYPE_FIT,GarminConnect::DATA_TYPE_GOOGLE_EARTH,GarminConnect::DATA_TYPE_GPX,GarminConnect::DATA_TYPE_TCX]);
        $this->exportFormat = $helper->ask($input,$output,$question);


        $output->writeln(sprintf("Exporting: %s",implode(',',$this->typesToExport)));
        $output->writeln('Logging into Garmin! ');
        $output->writeln(sprintf("Using username %s",$username));
        $output->writeln(sprintf("Using password %s",$password));
        $this->client = new GarminConnectExtended(['username'=>$username,'password'=>$password]);
        $failures = false;
        foreach($this->typesToExport as $type){
            switch($type){
                case GarminConnectExtended::EXPORT_TYPE_SEGMENTS:
                    if($this->exportSegments($output) == COMMAND::FAILURE){
                        $failures = true;
                        $output->writeln("Failure during export of activities");
                    }
                    break;
                case GarminConnectExtended::EXPORT_TYPE_ACTIVITIES:
                    if($this->exportActivities($output) == COMMAND::FAILURE){
                        $failures = true;
                        $output->writeln("Failure during export of activities");
                    }
                    break;
                case GarminConnectExtended::EXPORT_TYPE_WORKOUTS:
                    if($this->exportWorkouts($output) == COMMAND::FAILURE){
                        $failures = true;
                        $output->writeln("Failure during export of activities");
                    }
                    break;
            }

        }

        if($failures){
            return COMMAND::FAILURE;
        }
        RETURN COMMAND::SUCCESS;


    }

    /**
     * @param OutputInterface $output
     * @return int
     * @throws GarminConnect\exceptions\UnexpectedResponseCodeException
     */
    protected function exportActivities(OutputInterface $output): int
    {
        $output->writeln('Start retrieving activities');
        $activities = array();
        if ($this->whatToExport == 'all') {
            $intStart = 0;
            $limit = 500;
            $result = $this->client->getActivityList($intStart, $limit, null, 'startLocal', 'desc');
            while (!empty($result)) {
                $activities = array_merge($activities, $result);
                $intStart += 500;
                $limit += 500;
                $result = $this->client->getActivityList($intStart, $limit, null, 'startLocal', 'desc');
            }

        } else {
            $activities = $this->client->getActivityList(0, 10, null, 'startLocal', 'desc');
        }

        $output->writeln(sprintf("Found %s activities", count($activities)));
        $failures = false;
        foreach ($activities as $activity) {
            $output->writeln(sprintf('Retrieve %s for activity %s', $this->exportFormat, $activity->activityId));
            $gpx = $this->client->getDataFile($this->exportFormat, $activity->activityId);
            $filename = sprintf("%s/%s.%s", $this->workingDir, $activity->activityId, $this->exportFormat);
            $output->writeln("Exporting to {$filename}");
            if (!file_exists($filename)) {
                $filehandle = fopen($filename, "w");
                if ($filehandle === false) {
                    $output->writeln("Could not export to file!");
                    $failures = true;
                } else {
                    fwrite($filehandle, $gpx);
                    fclose($filehandle);
                    $output->writeln(sprintf("Done exporting %s", $activity->activityId));
                }
            } else {
                $output->writeln(sprintf("File %s already exists", $filename));
            }
        }
        if ($failures) {
            return COMMAND::FAILURE;
        }
        return COMMAND::SUCCESS;
    }

    private function exportWorkouts(OutputInterface $output)
    {
        return COMMAND::SUCCESS;
    }

    private function exportSegments(OutputInterface $output)
    {
        $segments = $this->client->getMySegments();
        $filename = sprintf("%s/%s.%s", $this->workingDir, "mysegments", "json");
        $output->writeln("Exporting to {$filename}");
        if (!file_exists($filename)) {
            $filehandle = fopen($filename, "w");
            if ($filehandle === false) {
                $output->writeln("Could not export to file!");
                $failures = true;
            } else {
                fwrite($filehandle, $segments);
                fclose($filehandle);
                $output->writeln(sprintf("Done exporting %s", "segments"));
            }
        } else {
            $output->writeln(sprintf("File %s already exists", $filename));
        }

        return COMMAND::SUCCESS;
    }


}